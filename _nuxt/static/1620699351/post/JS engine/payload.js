__NUXT_JSONP__("/post/JS%20engine", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_,a$,ba,bb,bc,bd,be,bf,bg,bh,bi,bj,bk,bl,bm,bn,bo,bp,bq,br,bs,bt,bu,bv,bw,bx,by,bz,bA,bB,bC,bD,bE,bF,bG,bH,bI,bJ,bK,bL,bM,bN){return {data:[{article:{slug:"JS engine",description:"JS 源码通过 parser（分析器）转化为 AST（抽象语法树），再经过 interpreter（解释器）解析为 bytecode（字节码）。 为了提高运行效率，optimizing compiler（优化编辑器）负责生成 optimized code（优化后的机器码）。 本文主要从 AST 之后说起。",title:"《JS 引擎基础之 Shapes and Inline Caches》",author:"千叶麻衣",tags:["JavaScript","引擎","前沿技术"],archive:["网站源码"],toc:[{id:ao,depth:S,text:ap},{id:aq,depth:S,text:ar},{id:as,depth:F,text:at},{id:au,depth:F,text:av},{id:T,depth:F,text:T},{id:aw,depth:F,text:ax},{id:ay,depth:F,text:Q},{id:U,depth:F,text:U},{id:az,depth:S,text:aA},{id:aB,depth:F,text:P},{id:aC,depth:F,text:Q},{id:aD,depth:S,text:aE}],body:{type:"root",children:[{type:b,tag:V,props:{id:ao},children:[{type:b,tag:j,props:{href:"#1-%E5%BC%95%E8%A8%80",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:ap}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"本期精读的文章是："},{type:b,tag:j,props:{href:"https:\u002F\u002Fmathiasbynens.be\u002Fnotes\u002Fshapes-ics",rel:[aF,aG,aH],target:aI},children:[{type:a,value:"JS 引擎基础之 Shapes and Inline Caches"}]}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"一起了解下 JS 引擎是如何运作的吧！"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"JS 的运作机制可以分为 AST 分析、引擎执行两个步骤："}]},{type:a,value:d},{type:b,tag:j,props:{href:aJ,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:aJ},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"JS 源码通过 parser（分析器）转化为 AST（抽象语法树），再经过 interpreter（解释器）解析为 bytecode（字节码）。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"为了提高运行效率，optimizing compiler（优化编辑器）负责生成 optimized code（优化后的机器码）。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"本文主要从 AST 之后说起。"}]},{type:a,value:d},{type:b,tag:V,props:{id:aq},children:[{type:b,tag:j,props:{href:"#2-%E6%A6%82%E8%BF%B0",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:ar}]},{type:a,value:d},{type:b,tag:G,props:{id:as},children:[{type:b,tag:j,props:{href:"#js-%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:at}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"JS 代码可能在字节码或者优化后的机器码状态下执行，而生成字节码速度很快，而生成机器码就要慢一些了。"}]},{type:a,value:d},{type:b,tag:j,props:{href:aK,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:aK},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"V8 也类似，V8 将 interpreter 称为 Ignition（点火器），将 optimizing compiler 称为 TurboFan（涡轮风扇发动机）。"}]},{type:a,value:d},{type:b,tag:j,props:{href:aL,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:aL},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"可以理解为将代码先点火启动后，逐渐进入涡轮发动机提速。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"代码先快速解析成可执行的字节码，在执行过程中，利用执行中获取的数据（比如执行频率），将一些频率高的方法，通过优化编译器生成机器码以提速。"}]},{type:a,value:d},{type:b,tag:j,props:{href:aM,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:aM},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"火狐使用的 Mozilla 引擎有一点点不同，使用了两个优化编译器，先将字节码优化为部分机器码，再根据这个部分优化后的代码运行时拿到的数据进行最终优化，生成高度优化的机器码，如果优化失败将会回退到部分优化的机器码。"}]},{type:a,value:d},{type:b,tag:aN,props:{},children:[{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"笔者：不同前端引擎对 JS 优化方式大同小异，后面会继续列举不同前端引擎在解析器、编译器部分优化的方式。"}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:j,props:{href:aO,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:aO},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"微软的 Edge 浏览器，使用的 Chakra 引擎，优化方式与 Mozilla 很像，区别是第二个最终优化的编译器同时接收字节码和部分优化的机器码产生的数据，并且在优化失败后回退到第一步字节码而不是第二步。"}]},{type:a,value:d},{type:b,tag:j,props:{href:aP,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:aP},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"Safari、React Native 使用的 JSC 引擎则更为极端，使用了三个优化编译器，其优化是一步步渐进的，优化失败后都会回退到第一步部分优化的机器码。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"为什么不同前端引擎会使用不同的优化策略呢？这是由于 JS 要么使用解释器快速执行（生成字节码），或者优化成机器码后再执行，但优化消耗时间的并不总是小于字节码低效运行损耗的时间，所以有些引擎选择了多个优化编译器，逐层优化，尽可能在解析时间与执行效率中找到一个平衡点。"}]},{type:a,value:d},{type:b,tag:G,props:{id:au},children:[{type:b,tag:j,props:{href:"#js-%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:av}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"JS 是基于面向对象的，那么 JS 引擎是如何实现 JS 对象模型的呢？他们用了哪些技巧加速访问 JS 对象的属性？"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"和解析器、优化器一样，大部分主流 JS 引擎在对象模型实现上也很类似。"}]},{type:a,value:d},{type:b,tag:j,props:{href:aQ,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:aQ},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"ECMAScript 规范确定了对象模型就是一个以字符串为 key 的字典，除了其值以外，还定义了 "},{type:b,tag:f,props:{},children:[{type:a,value:"Writeable"}]},{type:a,value:i},{type:b,tag:f,props:{},children:[{type:a,value:"Enumerable"}]},{type:a,value:i},{type:b,tag:f,props:{},children:[{type:a,value:"Configurable"}]},{type:a,value:" 这些配置，表示这个 key 能否被重写、遍历访问、配置。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"虽然规范定义了 "},{type:b,tag:f,props:{},children:[{type:a,value:"[[]]"}]},{type:a,value:" 双括号的写法，那这不会暴露给用户，暴露给用户的是 "},{type:b,tag:f,props:{},children:[{type:a,value:"Object.getOwnPropertyDescriptor"}]},{type:a,value:" 这个 API，可以拿到某个属性的配置。"}]},{type:a,value:d},{type:b,tag:"hr",props:{},children:[]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:b,tag:"strong",props:{},children:[{type:a,value:"在 JS 中，数组是对象的特殊场景"}]},{type:a,value:"，相比对象，数组拥有特定的下标，根据 ECMAScript 规范规定，数组下标的长度最大为 2³²−1。同时数组拥有 "},{type:b,tag:f,props:{},children:[{type:a,value:aR}]},{type:a,value:" 属性："}]},{type:a,value:d},{type:b,tag:j,props:{href:aS,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:aS},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:aR}]},{type:a,value:" 只是一个不可枚举、不可配置的属性，并且在数组赋值时，会自动更新数值："}]},{type:a,value:d},{type:b,tag:j,props:{href:aT,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:aT},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"所以数组是特殊的对象，结构完全一致。"}]},{type:a,value:d},{type:b,tag:G,props:{id:T},children:[{type:b,tag:j,props:{href:"#%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:T}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"属性访问是最常见的，所以 JS 引擎必须对属性访问做优化。"}]},{type:a,value:d},{type:b,tag:"h4",props:{id:"shapes"},children:[{type:b,tag:j,props:{href:"#shapes",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:P}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"JS 编程中，给不同对象相同的 key 名很常见，访问不同对象的同一个 "},{type:b,tag:f,props:{},children:[{type:a,value:ac}]},{type:a,value:" 也很常见："}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:f,props:{},children:[{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:ad},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:a,value:ae},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:B}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,M]},children:[{type:a,value:aU}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:O}]},{type:a,value:aV},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:B}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,M]},children:[{type:a,value:"2"}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:af},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:a,value:ae},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:B}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,M]},children:[{type:a,value:"3"}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:O}]},{type:a,value:aV},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:B}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,M]},children:[{type:a,value:"4"}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:aW},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:C}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,C]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:D}]},{type:a,value:aX},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:E}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:a,value:l},{type:b,tag:c,props:{className:[e,"builtin"]},children:[{type:a,value:"console"}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[e,C]},children:[{type:a,value:"log"}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:D}]},{type:a,value:aX},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:N}]},{type:a,value:A},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:l},{type:b,tag:c,props:{className:[e,aY]},children:[{type:a,value:"\u002F\u002F          ^^^^^^^^"}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:a,value:aW},{type:b,tag:c,props:{className:[e,C]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:D}]},{type:a,value:ah},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,C]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:D}]},{type:a,value:W},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"这时 "},{type:b,tag:f,props:{},children:[{type:a,value:ah}]},{type:a,value:aZ},{type:b,tag:f,props:{},children:[{type:a,value:W}]},{type:a,value:" 拥有一个相同的 "},{type:b,tag:f,props:{},children:[{type:a,value:"shape"}]},{type:a,value:"。拿拥有 "},{type:b,tag:f,props:{},children:[{type:a,value:A}]},{type:a,value:"、"},{type:b,tag:f,props:{},children:[{type:a,value:X}]},{type:a,value:" 属性的对象来看："}]},{type:a,value:d},{type:b,tag:j,props:{href:a_,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:a_},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"如果访问 "},{type:b,tag:f,props:{},children:[{type:a,value:"object.y"}]},{type:a,value:"，JS 引擎会先找到 key "},{type:b,tag:f,props:{},children:[{type:a,value:X}]},{type:a,value:"，再查找 "},{type:b,tag:f,props:{},children:[{type:a,value:"[[value]]"}]},{type:a,value:R}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"如果将属性值也存储在 JSObject 中，像 "},{type:b,tag:f,props:{},children:[{type:a,value:ah}]},{type:a,value:i},{type:b,tag:f,props:{},children:[{type:a,value:W}]},{type:a,value:" 就会出现许多冗余数据，因此引擎单独存储 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:"，与真实对象隔离："}]},{type:a,value:d},{type:b,tag:j,props:{href:a$,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:a$},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"这样具有相同结构的对象可以共享 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:"。所有 JS 引擎都是用这种方式优化对象，但并不都称为 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:"，这里就不详细罗列了，可以去原文查看在各引擎中 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:" 的别名。"}]},{type:a,value:d},{type:b,tag:G,props:{id:aw},children:[{type:b,tag:j,props:{href:"#transition-chains-%E5%92%8C-transition-trees",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:ax}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"如果给一个对象增加了 "},{type:b,tag:f,props:{},children:[{type:a,value:"key"}]},{type:a,value:"，JS 引擎如何生成新的 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:" 呢？"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"这种 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:" 链式创建的过程，称为 Transition chains:"}]},{type:a,value:d},{type:b,tag:j,props:{href:ba,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:ba},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"开始创建空对象时，JSObject 和 Shape 都是空，当为 "},{type:b,tag:f,props:{},children:[{type:a,value:A}]},{type:a,value:" 赋值 "},{type:b,tag:f,props:{},children:[{type:a,value:Y}]},{type:a,value:bb},{type:b,tag:f,props:{},children:[{type:a,value:"0"}]},{type:a,value:bc},{type:b,tag:f,props:{},children:[{type:a,value:Y}]},{type:a,value:"，并且 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:bd},{type:b,tag:f,props:{},children:[{type:a,value:A}]},{type:a,value:be},{type:b,tag:f,props:{},children:[{type:a,value:ai}]},{type:a,value:"，当赋值 "},{type:b,tag:f,props:{},children:[{type:a,value:X}]},{type:a,value:" 为 "},{type:b,tag:f,props:{},children:[{type:a,value:Z}]},{type:a,value:bb},{type:b,tag:f,props:{},children:[{type:a,value:aU}]},{type:a,value:bc},{type:b,tag:f,props:{},children:[{type:a,value:Z}]},{type:a,value:"，并将 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:bd},{type:b,tag:f,props:{},children:[{type:a,value:A}]},{type:a,value:" 和 "},{type:b,tag:f,props:{},children:[{type:a,value:X}]},{type:a,value:be},{type:b,tag:f,props:{},children:[{type:a,value:bf}]},{type:a,value:R}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"而且可以再优化，"},{type:b,tag:f,props:{},children:[{type:a,value:bf}]},{type:a,value:" 由于被 "},{type:b,tag:f,props:{},children:[{type:a,value:ai}]},{type:a,value:" 指向，所以可以省略 "},{type:b,tag:f,props:{},children:[{type:a,value:A}]},{type:a,value:" 这个属性："}]},{type:a,value:d},{type:b,tag:j,props:{href:bg,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:bg},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:aN,props:{},children:[{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"笔者：当然这里说的主要是优化技巧，我们可以看出来，JS 引擎在做架构设计时没有考虑优化问题，而在架构设计完后，再回过头对时间和空间进行优化，这是架构设计的通用思路。"}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"如果没有连续的父 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:"，比如分别创建两个对象："}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:f,props:{},children:[{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:ad},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:bh},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:N}]},{type:a,value:bi},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,M]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:af},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:"\nobject2"},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:N}]},{type:a,value:"y "},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,M]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"这时要通过 Transition trees 来优化："}]},{type:a,value:d},{type:b,tag:j,props:{href:bj,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:bj},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"可以看到，两个 "},{type:b,tag:f,props:{},children:[{type:a,value:ai}]},{type:a,value:i},{type:b,tag:f,props:{},children:[{type:a,value:"Shape(y)"}]},{type:a,value:" 分别继承 "},{type:b,tag:f,props:{},children:[{type:a,value:bk}]},{type:a,value:"。当然也不是任何时候都会创建空 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:"，比如下面的情况："}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:f,props:{},children:[{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:ad},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:bh},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:N}]},{type:a,value:bi},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,M]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:af},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:a,value:ae},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:B}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,M]},children:[{type:a,value:Z}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"生成的 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:" 如下图所示："}]},{type:a,value:d},{type:b,tag:j,props:{href:bl,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:bl},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"可以看到，由于 "},{type:b,tag:f,props:{},children:[{type:a,value:W}]},{type:a,value:" 并不是从空对象开始的，所以并不会从 "},{type:b,tag:f,props:{},children:[{type:a,value:bk}]},{type:a,value:" 开始继承。"}]},{type:a,value:d},{type:b,tag:G,props:{id:ay},children:[{type:b,tag:j,props:{href:"#inline-caches",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:Q}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"大概可以翻译为“局部缓存”，JS 引擎为了提高对象查找效率，需要在局部做高效缓存。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"比如有一个函数 "},{type:b,tag:f,props:{},children:[{type:a,value:bm}]},{type:a,value:"，从 "},{type:b,tag:f,props:{},children:[{type:a,value:aj}]},{type:a,value:" 获取值："}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:f,props:{},children:[{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:C}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,C]},children:[{type:a,value:bm}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:D}]},{type:a,value:"o"},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:E}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:a,value:l},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:"return"}]},{type:a,value:" o"},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:N}]},{type:a,value:A},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"JSC 引擎 生成的字节码结构是这样的："}]},{type:a,value:d},{type:b,tag:j,props:{href:bn,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:bn},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:_}]},{type:a,value:" 指令是获取 "},{type:b,tag:f,props:{},children:[{type:a,value:"arg1"}]},{type:a,value:" 参数指向的对象 "},{type:b,tag:f,props:{},children:[{type:a,value:A}]},{type:a,value:"，并存储在 "},{type:b,tag:f,props:{},children:[{type:a,value:bo}]},{type:a,value:"，第二步则返回 "},{type:b,tag:f,props:{},children:[{type:a,value:bo}]},{type:a,value:R}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"当执行函数 "},{type:b,tag:f,props:{},children:[{type:a,value:"getX({ x: 'a' })"}]},{type:a,value:" 时，引擎会在 "},{type:b,tag:f,props:{},children:[{type:a,value:_}]},{type:a,value:" 指令中缓存这个对象的 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:bp}]},{type:a,value:d},{type:b,tag:j,props:{href:bq,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:bq},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"这个对象的 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:" 记录了自己拥有的字段 "},{type:b,tag:f,props:{},children:[{type:a,value:A}]},{type:a,value:" 以及其对应的下标 "},{type:b,tag:f,props:{},children:[{type:a,value:br}]},{type:a,value:bp}]},{type:a,value:d},{type:b,tag:j,props:{href:bs,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:bs},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"执行 "},{type:b,tag:f,props:{},children:[{type:a,value:_}]},{type:a,value:" 时，引擎从 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:" 查找下标，找到 "},{type:b,tag:f,props:{},children:[{type:a,value:A}]},{type:a,value:"，这就是 "},{type:b,tag:f,props:{},children:[{type:a,value:aj}]},{type:a,value:" 的查找过程。但一旦找到，引擎就会将 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:" 保存的 "},{type:b,tag:f,props:{},children:[{type:a,value:br}]},{type:a,value:" 缓存起来，下次开始直接跳过 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:" 这一步："}]},{type:a,value:d},{type:b,tag:j,props:{href:bt,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:bt},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"以后访问 "},{type:b,tag:f,props:{},children:[{type:a,value:aj}]},{type:a,value:" 时，只要 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:" 相同，引擎直接从 "},{type:b,tag:f,props:{},children:[{type:a,value:_}]},{type:a,value:" 指令中缓存的下标中可以直接命中要查找的值，而这个缓存在指令中的下标就是 Inline Cache."}]},{type:a,value:d},{type:b,tag:G,props:{id:U},children:[{type:b,tag:j,props:{href:"#%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E4%BC%98%E5%8C%96",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:U}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"和对象一样，数组的存储也可以被优化，而由于数组的特殊性，不需要为每一项数据做完整的配置。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"比如这个数组："}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:f,props:{},children:[{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:bu},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:bv}]},{type:b,tag:c,props:{className:[e,ak]},children:[{type:a,value:"\"#jsconfeu\""}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:bw}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"JS 引擎同样通过 "},{type:b,tag:f,props:{},children:[{type:a,value:s}]},{type:a,value:" 与数据分离的方式存储："}]},{type:a,value:d},{type:b,tag:j,props:{href:bx,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:bx},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"JS 引擎将数组的值单独存储在 "},{type:b,tag:f,props:{},children:[{type:a,value:$}]},{type:a,value:" 结构中，而且它们通常都是可读可配置可枚举的，所以并不会像对象一样，为每个元素做配置。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"但如果是这种例子："}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:f,props:{},children:[{type:b,tag:c,props:{className:[e,aY]},children:[{type:a,value:"\u002F\u002F 永远不要这么做"}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:bu},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:by},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[e,C]},children:[{type:a,value:bz}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:bv}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:bw}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:O}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,ak]},children:[{type:a,value:"\"0\""}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:O}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:a,value:"\n  value"},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:B}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,ak]},children:[{type:a,value:"\"Oh noes!!1\""}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:O}]},{type:a,value:"\n  writable"},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:B}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,al]},children:[{type:a,value:am}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:O}]},{type:a,value:"\n  enumerable"},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:B}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,al]},children:[{type:a,value:am}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:O}]},{type:a,value:"\n  configurable"},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:B}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,al]},children:[{type:a,value:am}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"JS 引擎会存储一个 "},{type:b,tag:f,props:{},children:[{type:a,value:an}]},{type:a,value:" 类型，为每个数组元素做配置："}]},{type:a,value:d},{type:b,tag:j,props:{href:bA,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:bA},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"这样数组的优化就没有用了，后续的赋值都会基于这种比较浪费空间的 "},{type:b,tag:f,props:{},children:[{type:a,value:an}]},{type:a,value:" 结构。所以永远不要用 "},{type:b,tag:f,props:{},children:[{type:a,value:aa}]},{type:a,value:" 操作数组。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"通过对 JS 引擎原理的认识，作者总结了下面两点代码中的注意事项："}]},{type:a,value:d},{type:b,tag:bB,props:{},children:[{type:a,value:d},{type:b,tag:ab,props:{},children:[{type:a,value:bC},{type:b,tag:f,props:{},children:[{type:a,value:P}]},{type:a,value:R}]},{type:a,value:d},{type:b,tag:ab,props:{},children:[{type:a,value:bD},{type:b,tag:f,props:{},children:[{type:a,value:ac}]},{type:a,value:bE}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:V,props:{id:az},children:[{type:b,tag:j,props:{href:"#3-%E7%B2%BE%E8%AF%BB",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:aA}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"这次原理系列解读是针对 JS 引擎执行优化这个点的，而网页渲染流程大致如下："}]},{type:a,value:d},{type:b,tag:j,props:{href:bF,dataFancybox:m,className:[n]},children:[{type:a,value:l},{type:b,tag:o,props:{src:bF},children:[]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"可以看到 Script 在整个网页解析链路中位置是比较靠前的，JS 解析效率会直接影响网页的渲染，所以 JS 引擎通过解释器（parser）和优化器（optimizing compiler）尽可能对 JS 代码提效。"}]},{type:a,value:d},{type:b,tag:G,props:{id:aB},children:[{type:b,tag:j,props:{href:"#shapes-1",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:P}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"需要特别说明的是，Shapes 并不是原型链，原型链是面向开发者的概念，而 Shapes 是面向 JS 引擎的概念。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"比如如下代码："}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:f,props:{},children:[{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:bG},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:bH},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:bI},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"显然对象 "},{type:b,tag:f,props:{},children:[{type:a,value:j}]},{type:a,value:i},{type:b,tag:f,props:{},children:[{type:a,value:"b"}]},{type:a,value:i},{type:b,tag:f,props:{},children:[{type:a,value:"c"}]},{type:a,value:" 之间是没有关联的，但共享一个 Shapes。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"另外理解引擎的概念有助于我们站在语法层面对立面的角度思考问题：在 JS 学习阶段，我们会执着于思考如下几种创建对象方式的异同："}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:f,props:{},children:[{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:bG},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:y}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:bH},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:bJ}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,bK]},children:[{type:a,value:bL}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:bI},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:bJ}]},{type:a,value:i},{type:b,tag:c,props:{className:[e,bK]},children:[{type:a,value:"f1"}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:t}]},{type:a,value:" d "},{type:b,tag:c,props:{className:[e,k]},children:[{type:a,value:r}]},{type:a,value:by},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[e,C]},children:[{type:a,value:"create"}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:D}]},{type:b,tag:c,props:{className:[e,q]},children:[{type:a,value:"null"}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[e,g]},children:[{type:a,value:p}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"比如上面四种情况，我们要理解在什么情况下，用何种方式创建对象性能最优。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"但站在 JS 引擎优化角度去考虑，JS 引擎更希望我们都通过 "},{type:b,tag:f,props:{},children:[{type:a,value:"const a = {}"}]},{type:a,value:" 这种看似最没有难度的方式创建对象，因为可以共享 Shape。而与其他方式混合使用，可能在逻辑上做到了优化，但阻碍了 JS 引擎做自动优化，可能会得不偿失。"}]},{type:a,value:d},{type:b,tag:G,props:{id:aC},children:[{type:b,tag:j,props:{href:"#inline-caches-1",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:Q}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"对象级别的优化已经很极致了，工程代码中也没有机会帮助 JS 引擎做得更好，值得注意的是不要对数组使用 "},{type:b,tag:f,props:{},children:[{type:a,value:bL}]},{type:a,value:" 对象下的方法，尤其是 "},{type:b,tag:f,props:{},children:[{type:a,value:bz}]},{type:a,value:"，因为这会让 JS 引擎在存储数组元素时，使用 "},{type:b,tag:f,props:{},children:[{type:a,value:an}]},{type:a,value:" 结构替代 "},{type:b,tag:f,props:{},children:[{type:a,value:$}]},{type:a,value:"，而 "},{type:b,tag:f,props:{},children:[{type:a,value:$}]},{type:a,value:" 结构是共享 "},{type:b,tag:f,props:{},children:[{type:a,value:"PropertyDescriptor"}]},{type:a,value:" 的。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"但也有难以避免的情况，比如使用 "},{type:b,tag:f,props:{},children:[{type:a,value:aa}]},{type:a,value:" 监听数组变化时，就不得不破坏 JS 引擎渲染了。"}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"笔者写 "},{type:b,tag:j,props:{href:"https:\u002F\u002Fgithub.com\u002Fdobjs\u002Fdob",rel:[aF,aG,aH],target:aI},children:[{type:a,value:"dob"}]},{type:a,value:" 的时候，使用 "},{type:b,tag:f,props:{},children:[{type:a,value:bM}]},{type:a,value:" 监听数组变化，这并不会改变 "},{type:b,tag:f,props:{},children:[{type:a,value:$}]},{type:a,value:" 的结构，所以这也从另一个侧面证明了使用 "},{type:b,tag:f,props:{},children:[{type:a,value:bM}]},{type:a,value:" 监听对象变化比 "},{type:b,tag:f,props:{},children:[{type:a,value:aa}]},{type:a,value:" 更优，因为 "},{type:b,tag:f,props:{},children:[{type:a,value:aa}]},{type:a,value:" 会破坏 JS 引擎对数组做的优化。"}]},{type:a,value:d},{type:b,tag:V,props:{id:aD},children:[{type:b,tag:j,props:{href:"#4-%E6%80%BB%E7%BB%93",ariaHidden:u,tabIndex:v},children:[{type:b,tag:c,props:{className:[w,x]},children:[]}]},{type:a,value:aE}]},{type:a,value:d},{type:b,tag:h,props:{},children:[{type:a,value:"本文主要介绍了 JS 引擎两个概念： "},{type:b,tag:f,props:{},children:[{type:a,value:P}]},{type:a,value:aZ},{type:b,tag:f,props:{},children:[{type:a,value:Q}]},{type:a,value:"，通过认识 JS 引擎的优化方式，在编程中需要注意以下两件事："}]},{type:a,value:d},{type:b,tag:bB,props:{},children:[{type:a,value:d},{type:b,tag:ab,props:{},children:[{type:a,value:bC},{type:b,tag:f,props:{},children:[{type:a,value:P}]},{type:a,value:R}]},{type:a,value:d},{type:b,tag:ab,props:{},children:[{type:a,value:bD},{type:b,tag:f,props:{},children:[{type:a,value:ac}]},{type:a,value:bE}]},{type:a,value:d}]}]},dir:"\u002Farticles",path:"\u002Farticles\u002FJS engine",extension:".md",createdAt:bN,updatedAt:bN},tags:{}}],fetch:{},mutations:void 0}}("text","element","span","\n","token","code","punctuation","p"," ","a","operator","\n  ","preview","image","img",";","keyword","=","Shape","const","true",-1,"icon","icon-link","{","}","x",":","function","(",")",3,"h3","div","nuxt-content-highlight","pre","language-typescript","line-numbers","number",".",",","Shapes","Inline Caches","。",2,"属性访问效率优化","数组存储优化","h2","object2","y","5","6","get_by_id","Elements","Object.defineProperty","li","propertyKey"," object1 "," x"," object2 ","logX","object1","Shape(x)","o.x","string","boolean","false","Dictionary Elements","1-引言","1 引言","2-概述","2 概述","js-的解释器、优化器","JS 的解释器、优化器","js-的对象模型","JS 的对象模型","transition-chains-和-transition-trees","Transition chains 和 Transition trees","inline-caches","3-精读","3 精读","shapes-1","inline-caches-1","4-总结","4 总结","nofollow","noopener","noreferrer","_blank","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808270-a775b730-770d-11e8-95c9-160d084ea4ad.png","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808280-ba8f9d9a-770d-11e8-9d46-cf13234eb5d0.png","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808284-c07ed20c-770d-11e8-8a68-e10f952edcdd.png","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808287-c4fba90e-770d-11e8-985d-c70615b25b1d.png","blockquote","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808289-ca5ebe7c-770d-11e8-85f9-58df2bf5982a.png","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808291-d0cc3456-770d-11e8-9587-8e2562756411.png","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808298-e8cce80c-770d-11e8-994b-1d6f30e2bfe3.png","length","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808304-fd195c00-770d-11e8-8e03-7746ecd8aac9.png","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808308-0446ba5e-770e-11e8-895a-e2ed7231869d.png","1"," y","\n\n","object","comment"," 与 ","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808313-1409d1e2-770e-11e8-8e9b-d8bdf31a17cf.png","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808322-2d1566ec-770e-11e8-98f7-ca87edeaa998.png","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808324-39f9f6c0-770e-11e8-8dd1-2bd43f65bd61.png"," 时，在 JSObject 下标 "," 的位置添加了 "," 指向了拥有字段 "," 的 ","Shape(x, y)","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808327-4a65ef8c-770e-11e8-9c05-3394cb6a2047.png","\nobject1","x ","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808331-64c2378c-770e-11e8-9f74-0cc41f8844b3.png","Shape(empty)","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808333-75bb1a36-770e-11e8-846a-5de14ae1fb90.png","getX","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808339-851a4574-770e-11e8-8369-56253847d3be.png","loc0","：","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808343-94cea5fa-770e-11e8-8017-684f01e1ca38.png","offset","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808347-99385d7a-770e-11e8-8290-0537571dd15e.png","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808350-9eb682fe-770e-11e8-951a-b6ec25ddb7a8.png"," array ","[","]","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808630-f6d6e628-7712-11e8-9e67-847d88a26eba.png"," Object","defineProperty","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808631-fb681158-7712-11e8-9a48-62eff9659ba1.png","ol","尽量以相同方式初始化对象，因为这样会生成较少的 ","不要混淆对象的 "," 与数组的下标，虽然都是用类似的结构存储，但 JS 引擎对数组下标做了额外优化。","https:\u002F\u002Fuser-images.githubusercontent.com\u002F7970947\u002F41808251-591c475c-770d-11e8-9670-40af1c9c7066.png"," a "," b "," c ","new","class-name","Object","proxy","2021-05-03T01:44:56.846Z")));