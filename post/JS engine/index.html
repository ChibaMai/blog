<!doctype html>
<html lang="en">
<head>
  <meta name="baidu-site-verification" content="code-oZ1BZC6Lnc">
  <title>千叶麻衣 Blog | JS engine</title><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta data-n-head="ssr" name="google-site-verification" content="aAQV8IgxP5WQiAuShum5fEQxY5S98Q8JSZoJe3kmwyY"><meta data-n-head="ssr" name="baidu-site-verification" content="code-SVyZBBxyAv"><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" lang="en"><meta data-n-head="ssr" language="English"><meta data-n-head="ssr" data-hid="name" key="name" property="name" name="name" content="千叶麻衣 Blog"><meta data-n-head="ssr" data-hid="description" key="description" property="description" name="description" content="本站是一个牛皮的技术博客。记录生活中遇到的问题，以及经验总结和分享！"><meta data-n-head="ssr" data-hid="keywords" key="keywords" property="keywords" name="keywords" content="千叶麻衣,千叶,麻衣,语心,技术博客,免费软件分享,aftersoil,aftersoil-blog,wiki"><meta data-n-head="ssr" data-hid="charset" charset="utf-8"><meta data-n-head="ssr" data-hid="mobile-web-app-capable" name="mobile-web-app-capable" content="yes"><meta data-n-head="ssr" data-hid="apple-mobile-web-app-title" name="apple-mobile-web-app-title" content="千叶 Blog - 分享互联网的宝藏"><meta data-n-head="ssr" data-hid="theme-color" name="theme-color" content="#c2185b"><meta data-n-head="ssr" data-hid="og:type" name="og:type" property="og:type" content="website"><meta data-n-head="ssr" data-hid="og:title" name="og:title" property="og:title" content="千叶 Blog - 分享互联网的宝藏"><meta data-n-head="ssr" data-hid="og:site_name" name="og:site_name" property="og:site_name" content="千叶 Blog - 分享互联网的宝藏"><meta data-n-head="ssr" data-hid="og:description" name="og:description" property="og:description" content="本站是一个牛皮的技术博客。记录生活中遇到的问题，以及经验总结和分享！"><link data-n-head="ssr" rel="canonical" href="https://blog.chibamai.xyz/"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="ssr" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.min.css@8.0.1/normalize.min.css"><link data-n-head="ssr" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><link data-n-head="ssr" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace-theme-default.css"><link data-n-head="ssr" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link data-n-head="ssr" data-hid="shortcut-icon" rel="shortcut icon" href="/_nuxt/icons/icon_150x150.636274.png"><link data-n-head="ssr" data-hid="apple-touch-icon" rel="apple-touch-icon" href="/_nuxt/icons/icon_150x150.636274.png" sizes="150x150"><link data-n-head="ssr" rel="manifest" href="/_nuxt/manifest.c30db85d.json" data-hid="manifest"><script data-n-head="ssr" src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script data-n-head="ssr" src="https://cdn.jsdelivr.net/npm/aftersoil_rippler@1.3.0/rippler.js"></script><script data-n-head="ssr" src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script data-n-head="ssr" src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script data-n-head="ssr" src="https://www.jq22.com/demo/jsloading-141022114841/js/echo.min.js"></script><link rel="preload" href="/_nuxt/a976e81.js" as="script"><link rel="preload" href="/_nuxt/0ad070f.js" as="script"><link rel="preload" href="/_nuxt/css/d1ba4ef.css" as="style"><link rel="preload" href="/_nuxt/c85452a.js" as="script"><link rel="preload" href="/_nuxt/css/c346724.css" as="style"><link rel="preload" href="/_nuxt/0f88d19.js" as="script"><link rel="preload" href="/_nuxt/css/1a93342.css" as="style"><link rel="preload" href="/_nuxt/14ca14c.js" as="script"><link rel="preload" href="/_nuxt/5b4962e.js" as="script"><link rel="stylesheet" href="/_nuxt/css/d1ba4ef.css"><link rel="stylesheet" href="/_nuxt/css/c346724.css"><link rel="stylesheet" href="/_nuxt/css/1a93342.css"><link rel="preload" href="/_nuxt/static/1621236686/post/JS%20engine/state.js" as="script"><link rel="preload" href="/_nuxt/static/1621236686/post/JS%20engine/payload.js" as="script"><link rel="preload" href="/_nuxt/static/1621236686/manifest.js" as="script">
  <meta name="google-site-verification" content="google-site-verification=aAQV8IgxP5WQiAuShum5fEQxY5S98Q8JSZoJe3kmwyY">
  <meta name="baidu-site-verification" content="code-SVyZBBxyAv">
</head>
<body class="mdui-drawer-body mdui-drawer-body-left mdui-appbar-with-toolbar" data-hidden="true">

  <script data-n-head="ssr" data-hid="nuxt-color-mode-script" data-pbody="true">!function(){"use strict";var t=window,e=document,s=e.documentElement,a=["dark","light"],o=window.localStorage.getItem("nuxt-color-mode")||"system",c="system"===o?n():o,e=e.body.getAttribute("data-color-mode-forced");function r(e){e+="-mode";s.classList?s.classList.add(e):s.className+=" "+e}function l(e){return t.matchMedia("(prefers-color-scheme"+e+")")}function n(){if(t.matchMedia&&"not all"!==l("").media)for(var e of a)if(l(":"+e).matches)return e;return"light"}r(c=e?e:c),t.__NUXT_COLOR_MODE__={preference:o,value:c,getColorScheme:n,addClass:r,removeClass:function(e){e+="-mode";s.classList?s.classList.remove(e):s.className=s.className.replace(new RegExp(e,"g"),"")}}}()</script><div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="app-container"><div class="mdui-appbar mdui-appbar-fixed" data-v-7c468de6><div class="mdui-toolbar mdui-color-indigo" data-v-7c468de6><a href="javascript:;" data-ripple="ripple" id="toolbar" class="mdui-btn mdui-btn-icon" data-v-644a57c6 data-v-7c468de6><i class="fa fa-bars" data-v-644a57c6></i></a> <a href="/" class="mdui-typo-headline nuxt-link-active" data-v-7c468de6>千叶麻衣 Blog</a> <div class="appbar-nav" data-v-7ca9e1bf data-v-7c468de6></div> <div class="theme-modle" data-v-75bc069a data-v-7c468de6><i class="ivu-icon ivu-icon-ios-color-palette theme" data-v-75bc069a></i></div> <div class="search" data-v-cd3b156e data-v-7c468de6><a href="javascript:;" data-ripple="ripple" class="mdui-btn mdui-btn-icon" data-v-cd3b156e><i class="ivu-icon ivu-icon-md-search" data-v-cd3b156e></i></a> <div class="search-content" data-v-cd3b156e><div title="关闭搜索" class="search-mask" data-v-cd3b156e></div> <i class="searchClose ivu-icon ivu-icon-md-close" data-v-cd3b156e></i> <div class="search-bar" data-v-cd3b156e><input type="search" autocomplete="off" placeholder="请输入您要搜索的字段" name="search" id="search" focus="focus" data-v-cd3b156e> <!----></div></div></div></div></div> <div class="mdui-drawer" data-v-6aabb6a3><div class="my-info mdui-text-center" data-v-38819522 data-v-6aabb6a3><img src="/_nuxt/img/Avatar.8f62f10.jpg" alt class="mdui-img-circle mdui-img-fluid avatar" data-v-38819522> <span data-v-38819522>千叶麻衣 Blog<i class="fa fa-angle-down mdui-icon" data-v-38819522></i></span></div> <div class="mdui-list mdui-collapse-item mdui-ripple" data-v-5ddc15b0 data-v-6aabb6a3><ul class="ivu-menu ivu-menu-light ivu-menu-vertical" style="width:240px" data-v-5ddc15b0><li class="ivu-menu-submenu" data-v-5ddc15b0><div class="ivu-menu-submenu-title"><i class="mdui-icon mdui-text-color-blue ivu-icon ivu-icon-md-paper-plane" data-v-5ddc15b0></i>分类 <i class="ivu-icon ivu-icon-ios-arrow-down ivu-menu-submenu-title-icon"></i></div> <ul class="ivu-menu" style="display:none"></ul></li> <li class="ivu-menu-submenu" data-v-5ddc15b0><div class="ivu-menu-submenu-title"><i class="mdui-icddon mdui-text-color-orange ivu-icon ivu-icon-md-pricetag" data-v-5ddc15b0></i>页面 <i class="ivu-icon ivu-icon-ios-arrow-down ivu-menu-submenu-title-icon"></i></div> <ul class="ivu-menu" style="display:none"></ul></li> <li class="ivu-menu-submenu" data-v-5ddc15b0><div class="ivu-menu-submenu-title"><i class="mdui-icon mdui-text-color-green ivu-icon ivu-icon-md-ionic" data-v-5ddc15b0></i>友情链接 <i class="ivu-icon ivu-icon-ios-arrow-down ivu-menu-submenu-title-icon"></i></div> <ul class="ivu-menu" style="display:none"></ul></li></ul></div> <div class="mdui-divider" data-v-6aabb6a3></div> <div data-ripple="ripple" class="mdui-ripple hitokoto" data-v-20886b58 data-v-6aabb6a3><i class="mdui-icon mdui-text-color-cyan ivu-icon ivu-icon-md-notifications-outline" data-v-20886b58></i> <span class="hitokoto-content" data-v-20886b58></span></div></div> <div id="body" class="mdui-container-fluid vcomments" data-v-520e794a><div class="article-method" data-v-520e794a><div class="mdui-card mdui-hoverable mdui-typo" data-v-520e794a><div class="mdui-card-primary" data-v-520e794a><h1 class="mdui-card-primary-title" data-v-520e794a>《JS 引擎基础之 Shapes and Inline Caches》</h1> <div class="mdui-card-primary-subtitle" data-v-520e794a><span data-v-520e794a>作者: 千叶麻衣</span> <span data-v-520e794a>创建于: 2021-05-16 23:16:13</span> <span data-v-520e794a>更新于: 2021-05-16 23:16:13</span></div></div> <div class="nuxt-content" data-v-520e794a data-v-520e794a><h2 id="1-引言" data-v-520e794a data-v-520e794a><a href="#1-%E5%BC%95%E8%A8%80" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>1 引言</h2>
<p data-v-520e794a data-v-520e794a>本期精读的文章是：<a href="https://mathiasbynens.be/notes/shapes-ics" rel="nofollow noopener noreferrer" target="_blank" data-v-520e794a data-v-520e794a>JS 引擎基础之 Shapes and Inline Caches</a></p>
<p data-v-520e794a data-v-520e794a>一起了解下 JS 引擎是如何运作的吧！</p>
<p data-v-520e794a data-v-520e794a>JS 的运作机制可以分为 AST 分析、引擎执行两个步骤：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808270-a775b730-770d-11e8-95c9-160d084ea4ad.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808270-a775b730-770d-11e8-95c9-160d084ea4ad.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>JS 源码通过 parser（分析器）转化为 AST（抽象语法树），再经过 interpreter（解释器）解析为 bytecode（字节码）。</p>
<p data-v-520e794a data-v-520e794a>为了提高运行效率，optimizing compiler（优化编辑器）负责生成 optimized code（优化后的机器码）。</p>
<p data-v-520e794a data-v-520e794a>本文主要从 AST 之后说起。</p>
<h2 id="2-概述" data-v-520e794a data-v-520e794a><a href="#2-%E6%A6%82%E8%BF%B0" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>2 概述</h2>
<h3 id="js-的解释器、优化器" data-v-520e794a data-v-520e794a><a href="#js-%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>JS 的解释器、优化器</h3>
<p data-v-520e794a data-v-520e794a>JS 代码可能在字节码或者优化后的机器码状态下执行，而生成字节码速度很快，而生成机器码就要慢一些了。</p>
<a href="https://user-images.githubusercontent.com/7970947/41808280-ba8f9d9a-770d-11e8-9d46-cf13234eb5d0.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808280-ba8f9d9a-770d-11e8-9d46-cf13234eb5d0.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>V8 也类似，V8 将 interpreter 称为 Ignition（点火器），将 optimizing compiler 称为 TurboFan（涡轮风扇发动机）。</p>
<a href="https://user-images.githubusercontent.com/7970947/41808284-c07ed20c-770d-11e8-8a68-e10f952edcdd.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808284-c07ed20c-770d-11e8-8a68-e10f952edcdd.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>可以理解为将代码先点火启动后，逐渐进入涡轮发动机提速。</p>
<p data-v-520e794a data-v-520e794a>代码先快速解析成可执行的字节码，在执行过程中，利用执行中获取的数据（比如执行频率），将一些频率高的方法，通过优化编译器生成机器码以提速。</p>
<a href="https://user-images.githubusercontent.com/7970947/41808287-c4fba90e-770d-11e8-985d-c70615b25b1d.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808287-c4fba90e-770d-11e8-985d-c70615b25b1d.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>火狐使用的 Mozilla 引擎有一点点不同，使用了两个优化编译器，先将字节码优化为部分机器码，再根据这个部分优化后的代码运行时拿到的数据进行最终优化，生成高度优化的机器码，如果优化失败将会回退到部分优化的机器码。</p>
<blockquote data-v-520e794a data-v-520e794a>
<p data-v-520e794a data-v-520e794a>笔者：不同前端引擎对 JS 优化方式大同小异，后面会继续列举不同前端引擎在解析器、编译器部分优化的方式。</p>
</blockquote>
<a href="https://user-images.githubusercontent.com/7970947/41808289-ca5ebe7c-770d-11e8-85f9-58df2bf5982a.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808289-ca5ebe7c-770d-11e8-85f9-58df2bf5982a.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>微软的 Edge 浏览器，使用的 Chakra 引擎，优化方式与 Mozilla 很像，区别是第二个最终优化的编译器同时接收字节码和部分优化的机器码产生的数据，并且在优化失败后回退到第一步字节码而不是第二步。</p>
<a href="https://user-images.githubusercontent.com/7970947/41808291-d0cc3456-770d-11e8-9587-8e2562756411.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808291-d0cc3456-770d-11e8-9587-8e2562756411.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>Safari、React Native 使用的 JSC 引擎则更为极端，使用了三个优化编译器，其优化是一步步渐进的，优化失败后都会回退到第一步部分优化的机器码。</p>
<p data-v-520e794a data-v-520e794a>为什么不同前端引擎会使用不同的优化策略呢？这是由于 JS 要么使用解释器快速执行（生成字节码），或者优化成机器码后再执行，但优化消耗时间的并不总是小于字节码低效运行损耗的时间，所以有些引擎选择了多个优化编译器，逐层优化，尽可能在解析时间与执行效率中找到一个平衡点。</p>
<h3 id="js-的对象模型" data-v-520e794a data-v-520e794a><a href="#js-%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>JS 的对象模型</h3>
<p data-v-520e794a data-v-520e794a>JS 是基于面向对象的，那么 JS 引擎是如何实现 JS 对象模型的呢？他们用了哪些技巧加速访问 JS 对象的属性？</p>
<p data-v-520e794a data-v-520e794a>和解析器、优化器一样，大部分主流 JS 引擎在对象模型实现上也很类似。</p>
<a href="https://user-images.githubusercontent.com/7970947/41808298-e8cce80c-770d-11e8-994b-1d6f30e2bfe3.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808298-e8cce80c-770d-11e8-994b-1d6f30e2bfe3.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>ECMAScript 规范确定了对象模型就是一个以字符串为 key 的字典，除了其值以外，还定义了 <code data-v-520e794a data-v-520e794a>Writeable</code> <code data-v-520e794a data-v-520e794a>Enumerable</code> <code data-v-520e794a data-v-520e794a>Configurable</code> 这些配置，表示这个 key 能否被重写、遍历访问、配置。</p>
<p data-v-520e794a data-v-520e794a>虽然规范定义了 <code data-v-520e794a data-v-520e794a>[[]]</code> 双括号的写法，那这不会暴露给用户，暴露给用户的是 <code data-v-520e794a data-v-520e794a>Object.getOwnPropertyDescriptor</code> 这个 API，可以拿到某个属性的配置。</p>
<hr data-v-520e794a data-v-520e794a>
<p data-v-520e794a data-v-520e794a><strong data-v-520e794a data-v-520e794a>在 JS 中，数组是对象的特殊场景</strong>，相比对象，数组拥有特定的下标，根据 ECMAScript 规范规定，数组下标的长度最大为 2³²−1。同时数组拥有 <code data-v-520e794a data-v-520e794a>length</code> 属性：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808304-fd195c00-770d-11e8-8e03-7746ecd8aac9.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808304-fd195c00-770d-11e8-8e03-7746ecd8aac9.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a><code data-v-520e794a data-v-520e794a>length</code> 只是一个不可枚举、不可配置的属性，并且在数组赋值时，会自动更新数值：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808308-0446ba5e-770e-11e8-895a-e2ed7231869d.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808308-0446ba5e-770e-11e8-895a-e2ed7231869d.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>所以数组是特殊的对象，结构完全一致。</p>
<h3 id="属性访问效率优化" data-v-520e794a data-v-520e794a><a href="#%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>属性访问效率优化</h3>
<p data-v-520e794a data-v-520e794a>属性访问是最常见的，所以 JS 引擎必须对属性访问做优化。</p>
<h4 id="shapes" data-v-520e794a data-v-520e794a><a href="#shapes" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>Shapes</h4>
<p data-v-520e794a data-v-520e794a>JS 编程中，给不同对象相同的 key 名很常见，访问不同对象的同一个 <code data-v-520e794a data-v-520e794a>propertyKey</code> 也很常见：</p>
<div class="nuxt-content-highlight" data-v-520e794a data-v-520e794a><pre class="language-typescript line-numbers" data-v-520e794a data-v-520e794a><code data-v-520e794a data-v-520e794a><span class="token keyword" data-v-520e794a data-v-520e794a>const</span> object1 <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span> x<span class="token operator" data-v-520e794a data-v-520e794a>:</span> <span class="token number" data-v-520e794a data-v-520e794a>1</span><span class="token punctuation" data-v-520e794a data-v-520e794a>,</span> y<span class="token operator" data-v-520e794a data-v-520e794a>:</span> <span class="token number" data-v-520e794a data-v-520e794a>2</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>}</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
<span class="token keyword" data-v-520e794a data-v-520e794a>const</span> object2 <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span> x<span class="token operator" data-v-520e794a data-v-520e794a>:</span> <span class="token number" data-v-520e794a data-v-520e794a>3</span><span class="token punctuation" data-v-520e794a data-v-520e794a>,</span> y<span class="token operator" data-v-520e794a data-v-520e794a>:</span> <span class="token number" data-v-520e794a data-v-520e794a>4</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>}</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>

<span class="token keyword" data-v-520e794a data-v-520e794a>function</span> <span class="token function" data-v-520e794a data-v-520e794a>logX</span><span class="token punctuation" data-v-520e794a data-v-520e794a>(</span>object<span class="token punctuation" data-v-520e794a data-v-520e794a>)</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span>
  <span class="token builtin" data-v-520e794a data-v-520e794a>console</span><span class="token punctuation" data-v-520e794a data-v-520e794a>.</span><span class="token function" data-v-520e794a data-v-520e794a>log</span><span class="token punctuation" data-v-520e794a data-v-520e794a>(</span>object<span class="token punctuation" data-v-520e794a data-v-520e794a>.</span>x<span class="token punctuation" data-v-520e794a data-v-520e794a>)</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
  <span class="token comment" data-v-520e794a data-v-520e794a>//          ^^^^^^^^</span>
<span class="token punctuation" data-v-520e794a data-v-520e794a>}</span>

<span class="token function" data-v-520e794a data-v-520e794a>logX</span><span class="token punctuation" data-v-520e794a data-v-520e794a>(</span>object1<span class="token punctuation" data-v-520e794a data-v-520e794a>)</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
<span class="token function" data-v-520e794a data-v-520e794a>logX</span><span class="token punctuation" data-v-520e794a data-v-520e794a>(</span>object2<span class="token punctuation" data-v-520e794a data-v-520e794a>)</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
</code></pre></div>
<p data-v-520e794a data-v-520e794a>这时 <code data-v-520e794a data-v-520e794a>object1</code> 与 <code data-v-520e794a data-v-520e794a>object2</code> 拥有一个相同的 <code data-v-520e794a data-v-520e794a>shape</code>。拿拥有 <code data-v-520e794a data-v-520e794a>x</code>、<code data-v-520e794a data-v-520e794a>y</code> 属性的对象来看：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808313-1409d1e2-770e-11e8-8e9b-d8bdf31a17cf.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808313-1409d1e2-770e-11e8-8e9b-d8bdf31a17cf.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>如果访问 <code data-v-520e794a data-v-520e794a>object.y</code>，JS 引擎会先找到 key <code data-v-520e794a data-v-520e794a>y</code>，再查找 <code data-v-520e794a data-v-520e794a>[[value]]</code>。</p>
<p data-v-520e794a data-v-520e794a>如果将属性值也存储在 JSObject 中，像 <code data-v-520e794a data-v-520e794a>object1</code> <code data-v-520e794a data-v-520e794a>object2</code> 就会出现许多冗余数据，因此引擎单独存储 <code data-v-520e794a data-v-520e794a>Shape</code>，与真实对象隔离：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808322-2d1566ec-770e-11e8-98f7-ca87edeaa998.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808322-2d1566ec-770e-11e8-98f7-ca87edeaa998.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>这样具有相同结构的对象可以共享 <code data-v-520e794a data-v-520e794a>Shape</code>。所有 JS 引擎都是用这种方式优化对象，但并不都称为 <code data-v-520e794a data-v-520e794a>Shape</code>，这里就不详细罗列了，可以去原文查看在各引擎中 <code data-v-520e794a data-v-520e794a>Shape</code> 的别名。</p>
<h3 id="transition-chains-和-transition-trees" data-v-520e794a data-v-520e794a><a href="#transition-chains-%E5%92%8C-transition-trees" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>Transition chains 和 Transition trees</h3>
<p data-v-520e794a data-v-520e794a>如果给一个对象增加了 <code data-v-520e794a data-v-520e794a>key</code>，JS 引擎如何生成新的 <code data-v-520e794a data-v-520e794a>Shape</code> 呢？</p>
<p data-v-520e794a data-v-520e794a>这种 <code data-v-520e794a data-v-520e794a>Shape</code> 链式创建的过程，称为 Transition chains:</p>
<a href="https://user-images.githubusercontent.com/7970947/41808324-39f9f6c0-770e-11e8-8dd1-2bd43f65bd61.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808324-39f9f6c0-770e-11e8-8dd1-2bd43f65bd61.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>开始创建空对象时，JSObject 和 Shape 都是空，当为 <code data-v-520e794a data-v-520e794a>x</code> 赋值 <code data-v-520e794a data-v-520e794a>5</code> 时，在 JSObject 下标 <code data-v-520e794a data-v-520e794a>0</code> 的位置添加了 <code data-v-520e794a data-v-520e794a>5</code>，并且 <code data-v-520e794a data-v-520e794a>Shape</code> 指向了拥有字段 <code data-v-520e794a data-v-520e794a>x</code> 的 <code data-v-520e794a data-v-520e794a>Shape(x)</code>，当赋值 <code data-v-520e794a data-v-520e794a>y</code> 为 <code data-v-520e794a data-v-520e794a>6</code> 时，在 JSObject 下标 <code data-v-520e794a data-v-520e794a>1</code> 的位置添加了 <code data-v-520e794a data-v-520e794a>6</code>，并将 <code data-v-520e794a data-v-520e794a>Shape</code> 指向了拥有字段 <code data-v-520e794a data-v-520e794a>x</code> 和 <code data-v-520e794a data-v-520e794a>y</code> 的 <code data-v-520e794a data-v-520e794a>Shape(x, y)</code>。</p>
<p data-v-520e794a data-v-520e794a>而且可以再优化，<code data-v-520e794a data-v-520e794a>Shape(x, y)</code> 由于被 <code data-v-520e794a data-v-520e794a>Shape(x)</code> 指向，所以可以省略 <code data-v-520e794a data-v-520e794a>x</code> 这个属性：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808327-4a65ef8c-770e-11e8-9c05-3394cb6a2047.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808327-4a65ef8c-770e-11e8-9c05-3394cb6a2047.png" data-v-520e794a data-v-520e794a>
</a>
<blockquote data-v-520e794a data-v-520e794a>
<p data-v-520e794a data-v-520e794a>笔者：当然这里说的主要是优化技巧，我们可以看出来，JS 引擎在做架构设计时没有考虑优化问题，而在架构设计完后，再回过头对时间和空间进行优化，这是架构设计的通用思路。</p>
</blockquote>
<p data-v-520e794a data-v-520e794a>如果没有连续的父 <code data-v-520e794a data-v-520e794a>Shape</code>，比如分别创建两个对象：</p>
<div class="nuxt-content-highlight" data-v-520e794a data-v-520e794a><pre class="language-typescript line-numbers" data-v-520e794a data-v-520e794a><code data-v-520e794a data-v-520e794a><span class="token keyword" data-v-520e794a data-v-520e794a>const</span> object1 <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span><span class="token punctuation" data-v-520e794a data-v-520e794a>}</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
object1<span class="token punctuation" data-v-520e794a data-v-520e794a>.</span>x <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token number" data-v-520e794a data-v-520e794a>5</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
<span class="token keyword" data-v-520e794a data-v-520e794a>const</span> object2 <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span><span class="token punctuation" data-v-520e794a data-v-520e794a>}</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
object2<span class="token punctuation" data-v-520e794a data-v-520e794a>.</span>y <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token number" data-v-520e794a data-v-520e794a>6</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
</code></pre></div>
<p data-v-520e794a data-v-520e794a>这时要通过 Transition trees 来优化：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808331-64c2378c-770e-11e8-9f74-0cc41f8844b3.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808331-64c2378c-770e-11e8-9f74-0cc41f8844b3.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>可以看到，两个 <code data-v-520e794a data-v-520e794a>Shape(x)</code> <code data-v-520e794a data-v-520e794a>Shape(y)</code> 分别继承 <code data-v-520e794a data-v-520e794a>Shape(empty)</code>。当然也不是任何时候都会创建空 <code data-v-520e794a data-v-520e794a>Shape</code>，比如下面的情况：</p>
<div class="nuxt-content-highlight" data-v-520e794a data-v-520e794a><pre class="language-typescript line-numbers" data-v-520e794a data-v-520e794a><code data-v-520e794a data-v-520e794a><span class="token keyword" data-v-520e794a data-v-520e794a>const</span> object1 <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span><span class="token punctuation" data-v-520e794a data-v-520e794a>}</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
object1<span class="token punctuation" data-v-520e794a data-v-520e794a>.</span>x <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token number" data-v-520e794a data-v-520e794a>5</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
<span class="token keyword" data-v-520e794a data-v-520e794a>const</span> object2 <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span> x<span class="token operator" data-v-520e794a data-v-520e794a>:</span> <span class="token number" data-v-520e794a data-v-520e794a>6</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>}</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
</code></pre></div>
<p data-v-520e794a data-v-520e794a>生成的 <code data-v-520e794a data-v-520e794a>Shape</code> 如下图所示：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808333-75bb1a36-770e-11e8-846a-5de14ae1fb90.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808333-75bb1a36-770e-11e8-846a-5de14ae1fb90.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>可以看到，由于 <code data-v-520e794a data-v-520e794a>object2</code> 并不是从空对象开始的，所以并不会从 <code data-v-520e794a data-v-520e794a>Shape(empty)</code> 开始继承。</p>
<h3 id="inline-caches" data-v-520e794a data-v-520e794a><a href="#inline-caches" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>Inline Caches</h3>
<p data-v-520e794a data-v-520e794a>大概可以翻译为“局部缓存”，JS 引擎为了提高对象查找效率，需要在局部做高效缓存。</p>
<p data-v-520e794a data-v-520e794a>比如有一个函数 <code data-v-520e794a data-v-520e794a>getX</code>，从 <code data-v-520e794a data-v-520e794a>o.x</code> 获取值：</p>
<div class="nuxt-content-highlight" data-v-520e794a data-v-520e794a><pre class="language-typescript line-numbers" data-v-520e794a data-v-520e794a><code data-v-520e794a data-v-520e794a><span class="token keyword" data-v-520e794a data-v-520e794a>function</span> <span class="token function" data-v-520e794a data-v-520e794a>getX</span><span class="token punctuation" data-v-520e794a data-v-520e794a>(</span>o<span class="token punctuation" data-v-520e794a data-v-520e794a>)</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span>
  <span class="token keyword" data-v-520e794a data-v-520e794a>return</span> o<span class="token punctuation" data-v-520e794a data-v-520e794a>.</span>x<span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
<span class="token punctuation" data-v-520e794a data-v-520e794a>}</span>
</code></pre></div>
<p data-v-520e794a data-v-520e794a>JSC 引擎 生成的字节码结构是这样的：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808339-851a4574-770e-11e8-8369-56253847d3be.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808339-851a4574-770e-11e8-8369-56253847d3be.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a><code data-v-520e794a data-v-520e794a>get_by_id</code> 指令是获取 <code data-v-520e794a data-v-520e794a>arg1</code> 参数指向的对象 <code data-v-520e794a data-v-520e794a>x</code>，并存储在 <code data-v-520e794a data-v-520e794a>loc0</code>，第二步则返回 <code data-v-520e794a data-v-520e794a>loc0</code>。</p>
<p data-v-520e794a data-v-520e794a>当执行函数 <code data-v-520e794a data-v-520e794a>getX({ x: 'a' })</code> 时，引擎会在 <code data-v-520e794a data-v-520e794a>get_by_id</code> 指令中缓存这个对象的 <code data-v-520e794a data-v-520e794a>Shape</code>：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808343-94cea5fa-770e-11e8-8017-684f01e1ca38.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808343-94cea5fa-770e-11e8-8017-684f01e1ca38.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>这个对象的 <code data-v-520e794a data-v-520e794a>Shape</code> 记录了自己拥有的字段 <code data-v-520e794a data-v-520e794a>x</code> 以及其对应的下标 <code data-v-520e794a data-v-520e794a>offset</code>：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808347-99385d7a-770e-11e8-8290-0537571dd15e.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808347-99385d7a-770e-11e8-8290-0537571dd15e.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>执行 <code data-v-520e794a data-v-520e794a>get_by_id</code> 时，引擎从 <code data-v-520e794a data-v-520e794a>Shape</code> 查找下标，找到 <code data-v-520e794a data-v-520e794a>x</code>，这就是 <code data-v-520e794a data-v-520e794a>o.x</code> 的查找过程。但一旦找到，引擎就会将 <code data-v-520e794a data-v-520e794a>Shape</code> 保存的 <code data-v-520e794a data-v-520e794a>offset</code> 缓存起来，下次开始直接跳过 <code data-v-520e794a data-v-520e794a>Shape</code> 这一步：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808350-9eb682fe-770e-11e8-951a-b6ec25ddb7a8.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808350-9eb682fe-770e-11e8-951a-b6ec25ddb7a8.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>以后访问 <code data-v-520e794a data-v-520e794a>o.x</code> 时，只要 <code data-v-520e794a data-v-520e794a>Shape</code> 相同，引擎直接从 <code data-v-520e794a data-v-520e794a>get_by_id</code> 指令中缓存的下标中可以直接命中要查找的值，而这个缓存在指令中的下标就是 Inline Cache.</p>
<h3 id="数组存储优化" data-v-520e794a data-v-520e794a><a href="#%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E4%BC%98%E5%8C%96" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>数组存储优化</h3>
<p data-v-520e794a data-v-520e794a>和对象一样，数组的存储也可以被优化，而由于数组的特殊性，不需要为每一项数据做完整的配置。</p>
<p data-v-520e794a data-v-520e794a>比如这个数组：</p>
<div class="nuxt-content-highlight" data-v-520e794a data-v-520e794a><pre class="language-typescript line-numbers" data-v-520e794a data-v-520e794a><code data-v-520e794a data-v-520e794a><span class="token keyword" data-v-520e794a data-v-520e794a>const</span> array <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>[</span><span class="token string" data-v-520e794a data-v-520e794a>"#jsconfeu"</span><span class="token punctuation" data-v-520e794a data-v-520e794a>]</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
</code></pre></div>
<p data-v-520e794a data-v-520e794a>JS 引擎同样通过 <code data-v-520e794a data-v-520e794a>Shape</code> 与数据分离的方式存储：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808630-f6d6e628-7712-11e8-9e67-847d88a26eba.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808630-f6d6e628-7712-11e8-9e67-847d88a26eba.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>JS 引擎将数组的值单独存储在 <code data-v-520e794a data-v-520e794a>Elements</code> 结构中，而且它们通常都是可读可配置可枚举的，所以并不会像对象一样，为每个元素做配置。</p>
<p data-v-520e794a data-v-520e794a>但如果是这种例子：</p>
<div class="nuxt-content-highlight" data-v-520e794a data-v-520e794a><pre class="language-typescript line-numbers" data-v-520e794a data-v-520e794a><code data-v-520e794a data-v-520e794a><span class="token comment" data-v-520e794a data-v-520e794a>// 永远不要这么做</span>
<span class="token keyword" data-v-520e794a data-v-520e794a>const</span> array <span class="token operator" data-v-520e794a data-v-520e794a>=</span> Object<span class="token punctuation" data-v-520e794a data-v-520e794a>.</span><span class="token function" data-v-520e794a data-v-520e794a>defineProperty</span><span class="token punctuation" data-v-520e794a data-v-520e794a>(</span><span class="token punctuation" data-v-520e794a data-v-520e794a>[</span><span class="token punctuation" data-v-520e794a data-v-520e794a>]</span><span class="token punctuation" data-v-520e794a data-v-520e794a>,</span> <span class="token string" data-v-520e794a data-v-520e794a>"0"</span><span class="token punctuation" data-v-520e794a data-v-520e794a>,</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span>
  value<span class="token operator" data-v-520e794a data-v-520e794a>:</span> <span class="token string" data-v-520e794a data-v-520e794a>"Oh noes!!1"</span><span class="token punctuation" data-v-520e794a data-v-520e794a>,</span>
  writable<span class="token operator" data-v-520e794a data-v-520e794a>:</span> <span class="token boolean" data-v-520e794a data-v-520e794a>false</span><span class="token punctuation" data-v-520e794a data-v-520e794a>,</span>
  enumerable<span class="token operator" data-v-520e794a data-v-520e794a>:</span> <span class="token boolean" data-v-520e794a data-v-520e794a>false</span><span class="token punctuation" data-v-520e794a data-v-520e794a>,</span>
  configurable<span class="token operator" data-v-520e794a data-v-520e794a>:</span> <span class="token boolean" data-v-520e794a data-v-520e794a>false</span>
<span class="token punctuation" data-v-520e794a data-v-520e794a>}</span><span class="token punctuation" data-v-520e794a data-v-520e794a>)</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
</code></pre></div>
<p data-v-520e794a data-v-520e794a>JS 引擎会存储一个 <code data-v-520e794a data-v-520e794a>Dictionary Elements</code> 类型，为每个数组元素做配置：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808631-fb681158-7712-11e8-9a48-62eff9659ba1.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808631-fb681158-7712-11e8-9a48-62eff9659ba1.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>这样数组的优化就没有用了，后续的赋值都会基于这种比较浪费空间的 <code data-v-520e794a data-v-520e794a>Dictionary Elements</code> 结构。所以永远不要用 <code data-v-520e794a data-v-520e794a>Object.defineProperty</code> 操作数组。</p>
<p data-v-520e794a data-v-520e794a>通过对 JS 引擎原理的认识，作者总结了下面两点代码中的注意事项：</p>
<ol data-v-520e794a data-v-520e794a>
<li data-v-520e794a data-v-520e794a>尽量以相同方式初始化对象，因为这样会生成较少的 <code data-v-520e794a data-v-520e794a>Shapes</code>。</li>
<li data-v-520e794a data-v-520e794a>不要混淆对象的 <code data-v-520e794a data-v-520e794a>propertyKey</code> 与数组的下标，虽然都是用类似的结构存储，但 JS 引擎对数组下标做了额外优化。</li>
</ol>
<h2 id="3-精读" data-v-520e794a data-v-520e794a><a href="#3-%E7%B2%BE%E8%AF%BB" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>3 精读</h2>
<p data-v-520e794a data-v-520e794a>这次原理系列解读是针对 JS 引擎执行优化这个点的，而网页渲染流程大致如下：</p>
<a href="https://user-images.githubusercontent.com/7970947/41808251-591c475c-770d-11e8-9670-40af1c9c7066.png" data-fancybox="preview" class="image" data-v-520e794a data-v-520e794a>
  <img src="https://user-images.githubusercontent.com/7970947/41808251-591c475c-770d-11e8-9670-40af1c9c7066.png" data-v-520e794a data-v-520e794a>
</a>
<p data-v-520e794a data-v-520e794a>可以看到 Script 在整个网页解析链路中位置是比较靠前的，JS 解析效率会直接影响网页的渲染，所以 JS 引擎通过解释器（parser）和优化器（optimizing compiler）尽可能对 JS 代码提效。</p>
<h3 id="shapes-1" data-v-520e794a data-v-520e794a><a href="#shapes-1" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>Shapes</h3>
<p data-v-520e794a data-v-520e794a>需要特别说明的是，Shapes 并不是原型链，原型链是面向开发者的概念，而 Shapes 是面向 JS 引擎的概念。</p>
<p data-v-520e794a data-v-520e794a>比如如下代码：</p>
<div class="nuxt-content-highlight" data-v-520e794a data-v-520e794a><pre class="language-typescript line-numbers" data-v-520e794a data-v-520e794a><code data-v-520e794a data-v-520e794a><span class="token keyword" data-v-520e794a data-v-520e794a>const</span> a <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span><span class="token punctuation" data-v-520e794a data-v-520e794a>}</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
<span class="token keyword" data-v-520e794a data-v-520e794a>const</span> b <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span><span class="token punctuation" data-v-520e794a data-v-520e794a>}</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
<span class="token keyword" data-v-520e794a data-v-520e794a>const</span> c <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span><span class="token punctuation" data-v-520e794a data-v-520e794a>}</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
</code></pre></div>
<p data-v-520e794a data-v-520e794a>显然对象 <code data-v-520e794a data-v-520e794a>a</code> <code data-v-520e794a data-v-520e794a>b</code> <code data-v-520e794a data-v-520e794a>c</code> 之间是没有关联的，但共享一个 Shapes。</p>
<p data-v-520e794a data-v-520e794a>另外理解引擎的概念有助于我们站在语法层面对立面的角度思考问题：在 JS 学习阶段，我们会执着于思考如下几种创建对象方式的异同：</p>
<div class="nuxt-content-highlight" data-v-520e794a data-v-520e794a><pre class="language-typescript line-numbers" data-v-520e794a data-v-520e794a><code data-v-520e794a data-v-520e794a><span class="token keyword" data-v-520e794a data-v-520e794a>const</span> a <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token punctuation" data-v-520e794a data-v-520e794a>{</span><span class="token punctuation" data-v-520e794a data-v-520e794a>}</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
<span class="token keyword" data-v-520e794a data-v-520e794a>const</span> b <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token keyword" data-v-520e794a data-v-520e794a>new</span> <span class="token class-name" data-v-520e794a data-v-520e794a>Object</span><span class="token punctuation" data-v-520e794a data-v-520e794a>(</span><span class="token punctuation" data-v-520e794a data-v-520e794a>)</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
<span class="token keyword" data-v-520e794a data-v-520e794a>const</span> c <span class="token operator" data-v-520e794a data-v-520e794a>=</span> <span class="token keyword" data-v-520e794a data-v-520e794a>new</span> <span class="token class-name" data-v-520e794a data-v-520e794a>f1</span><span class="token punctuation" data-v-520e794a data-v-520e794a>(</span><span class="token punctuation" data-v-520e794a data-v-520e794a>)</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
<span class="token keyword" data-v-520e794a data-v-520e794a>const</span> d <span class="token operator" data-v-520e794a data-v-520e794a>=</span> Object<span class="token punctuation" data-v-520e794a data-v-520e794a>.</span><span class="token function" data-v-520e794a data-v-520e794a>create</span><span class="token punctuation" data-v-520e794a data-v-520e794a>(</span><span class="token keyword" data-v-520e794a data-v-520e794a>null</span><span class="token punctuation" data-v-520e794a data-v-520e794a>)</span><span class="token punctuation" data-v-520e794a data-v-520e794a>;</span>
</code></pre></div>
<p data-v-520e794a data-v-520e794a>比如上面四种情况，我们要理解在什么情况下，用何种方式创建对象性能最优。</p>
<p data-v-520e794a data-v-520e794a>但站在 JS 引擎优化角度去考虑，JS 引擎更希望我们都通过 <code data-v-520e794a data-v-520e794a>const a = {}</code> 这种看似最没有难度的方式创建对象，因为可以共享 Shape。而与其他方式混合使用，可能在逻辑上做到了优化，但阻碍了 JS 引擎做自动优化，可能会得不偿失。</p>
<h3 id="inline-caches-1" data-v-520e794a data-v-520e794a><a href="#inline-caches-1" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>Inline Caches</h3>
<p data-v-520e794a data-v-520e794a>对象级别的优化已经很极致了，工程代码中也没有机会帮助 JS 引擎做得更好，值得注意的是不要对数组使用 <code data-v-520e794a data-v-520e794a>Object</code> 对象下的方法，尤其是 <code data-v-520e794a data-v-520e794a>defineProperty</code>，因为这会让 JS 引擎在存储数组元素时，使用 <code data-v-520e794a data-v-520e794a>Dictionary Elements</code> 结构替代 <code data-v-520e794a data-v-520e794a>Elements</code>，而 <code data-v-520e794a data-v-520e794a>Elements</code> 结构是共享 <code data-v-520e794a data-v-520e794a>PropertyDescriptor</code> 的。</p>
<p data-v-520e794a data-v-520e794a>但也有难以避免的情况，比如使用 <code data-v-520e794a data-v-520e794a>Object.defineProperty</code> 监听数组变化时，就不得不破坏 JS 引擎渲染了。</p>
<p data-v-520e794a data-v-520e794a>笔者写 <a href="https://github.com/dobjs/dob" rel="nofollow noopener noreferrer" target="_blank" data-v-520e794a data-v-520e794a>dob</a> 的时候，使用 <code data-v-520e794a data-v-520e794a>proxy</code> 监听数组变化，这并不会改变 <code data-v-520e794a data-v-520e794a>Elements</code> 的结构，所以这也从另一个侧面证明了使用 <code data-v-520e794a data-v-520e794a>proxy</code> 监听对象变化比 <code data-v-520e794a data-v-520e794a>Object.defineProperty</code> 更优，因为 <code data-v-520e794a data-v-520e794a>Object.defineProperty</code> 会破坏 JS 引擎对数组做的优化。</p>
<h2 id="4-总结" data-v-520e794a data-v-520e794a><a href="#4-%E6%80%BB%E7%BB%93" aria-hidden="true" tabindex="-1" data-v-520e794a data-v-520e794a><span class="icon icon-link" data-v-520e794a data-v-520e794a></span></a>4 总结</h2>
<p data-v-520e794a data-v-520e794a>本文主要介绍了 JS 引擎两个概念： <code data-v-520e794a data-v-520e794a>Shapes</code> 与 <code data-v-520e794a data-v-520e794a>Inline Caches</code>，通过认识 JS 引擎的优化方式，在编程中需要注意以下两件事：</p>
<ol data-v-520e794a data-v-520e794a>
<li data-v-520e794a data-v-520e794a>尽量以相同方式初始化对象，因为这样会生成较少的 <code data-v-520e794a data-v-520e794a>Shapes</code>。</li>
<li data-v-520e794a data-v-520e794a>不要混淆对象的 <code data-v-520e794a data-v-520e794a>propertyKey</code> 与数组的下标，虽然都是用类似的结构存储，但 JS 引擎对数组下标做了额外优化。</li>
</ol></div></div> <div class="mdui-card mdui-hoverable vcomments" data-v-520e794a><div id="vcomments" data-v-74c818b0 data-v-520e794a></div></div></div> <div class="floatingMenu mdui-hidden-sm-down" data-v-dad3881a data-v-520e794a><div class="floatingMenu-tab" data-v-6ab87e66 data-v-dad3881a></div> <div class="floatingMenu-archive" data-v-b92824fe data-v-dad3881a></div> <div class="floatingMenu-tags" data-v-6cde03e2 data-v-dad3881a></div></div> <div class="anchor-link" data-v-520e794a><ul data-v-520e794a><li class="font-semibold" data-v-520e794a><a href="/post/JS%20engine#1-%E5%BC%95%E8%A8%80" class="hover:underline py-2" data-v-520e794a>1 引言</a></li><li class="font-semibold" data-v-520e794a><a href="/post/JS%20engine#2-%E6%A6%82%E8%BF%B0" class="hover:underline py-2" data-v-520e794a>2 概述</a></li><li data-v-520e794a><a href="/post/JS%20engine#js-%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8" class="hover:underline ml-2 pb-2" data-v-520e794a>JS 的解释器、优化器</a></li><li data-v-520e794a><a href="/post/JS%20engine#js-%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B" class="hover:underline ml-2 pb-2" data-v-520e794a>JS 的对象模型</a></li><li data-v-520e794a><a href="/post/JS%20engine#%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96" class="hover:underline ml-2 pb-2" data-v-520e794a>属性访问效率优化</a></li><li data-v-520e794a><a href="/post/JS%20engine#transition-chains-%E5%92%8C-transition-trees" class="hover:underline ml-2 pb-2" data-v-520e794a>Transition chains 和 Transition trees</a></li><li data-v-520e794a><a href="/post/JS%20engine#inline-caches" class="hover:underline ml-2 pb-2" data-v-520e794a>Inline Caches</a></li><li data-v-520e794a><a href="/post/JS%20engine#%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E4%BC%98%E5%8C%96" class="hover:underline ml-2 pb-2" data-v-520e794a>数组存储优化</a></li><li class="font-semibold" data-v-520e794a><a href="/post/JS%20engine#3-%E7%B2%BE%E8%AF%BB" class="hover:underline py-2" data-v-520e794a>3 精读</a></li><li data-v-520e794a><a href="/post/JS%20engine#shapes-1" class="hover:underline ml-2 pb-2" data-v-520e794a>Shapes</a></li><li data-v-520e794a><a href="/post/JS%20engine#inline-caches-1" class="hover:underline ml-2 pb-2" data-v-520e794a>Inline Caches</a></li><li class="font-semibold" data-v-520e794a><a href="/post/JS%20engine#4-%E6%80%BB%E7%BB%93" class="hover:underline py-2" data-v-520e794a>4 总结</a></li></ul></div></div> <div class="mdui-color-theme mdui-text-center" data-v-65b7d570><div class="mdui-typo" data-v-65b7d570><span data-v-65b7d570>©</span> <span data-v-65b7d570>2021</span> <a href="/" data-v-65b7d570>千叶麻衣 Blog.</a></div> <div class="mdui-typo" data-v-65b7d570><span data-v-65b7d570>由</span> <a href data-v-65b7d570>Typecho</a> <span data-v-65b7d570>强力驱动 . Theme By </span> <a href="/" data-v-65b7d570>Chiba Mai Blog.</a></div></div> <div data-ripple="ripple" class="mdui-fab mdui-icon ivu-back-top" style="bottom:50px;right:30px" data-v-91be1400><i class="ivu-icon ivu-icon-md-arrow-round-up" data-v-91be1400></i></div> <div class="mask-layer" data-v-5567646e></div></div></div></div><script defer src="/_nuxt/static/1621236686/post/JS%20engine/state.js"></script><script src="/_nuxt/a976e81.js" defer></script><script src="/_nuxt/14ca14c.js" defer></script><script src="/_nuxt/5b4962e.js" defer></script><script src="/_nuxt/0ad070f.js" defer></script><script src="/_nuxt/c85452a.js" defer></script><script src="/_nuxt/0f88d19.js" defer></script>

</body>
</html>
